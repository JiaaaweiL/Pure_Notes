1











## Execution model
multi-thread processor 的定义是：一个能够处理多条指令流，而不需要软件介入的处理器。  这意味着处理器内部可以在硬件中保存多个PC，从而能够跟踪多个指令流。   
- SMT: 一个core同时处理多个thread
- CMP: chip multiprocessing 是在一个芯片上集成多个独立的处理器核心，每个核心可以独立运行不同的线程。(奇奇怪怪）
多线程技术的目的是解决处理器在单线程被阻塞或暂停时无法充分利用执行资源的问题。特别是在超标量处理器（Superscalar Processor）中，当一个线程的执行暂停或效率低下时，处理器资源会闲置，从而浪费了执行潜力。

- 多线程的目的：**解决浪费**  解决单线程被阻塞或暂停时无法充分利用FU的浪费。特别是在Superscalar Processor中，当一个线程的执行stall或FU要multi cycle然后RAW反压上游issue时，处理器资源会闲置，从而浪费了执行潜力。
- 将资源浪费分成 vertical 和 horizontal：

  ![image](https://github.com/user-attachments/assets/7ee6d245-4c1f-4f10-b6c1-51ff6b461047)     
一行四个是四个FU。 空白表示正在浪费 Vertical指处理器在每个周期中，无法充分利用其所有的指令执行单元， horizontal指的是在流水线的不同阶段中，由于指令之间的依赖性或者等待内存等原因。      
仔细想一想，除了引入SMT之外还能用什么来解决？ 更深的ROB->更多的ILP能够解决。但也有marginal effect， 只能解决一些些。     
- horizontal 浪费： 当指令之间存在依赖性，导致处理器无法充分利用其发射带宽时，就会产生水平浪费。   
- Vertical 浪费： 垂直浪费发生在整个流水线由于某种原因（如长延迟事件、数据依赖等）暂停工作，导致处理器在某个周期中没有发射任何指令。（大概率是store或者长时间的ALU指令干的）

MTprocessor要求保存多个上下文的状态。最重要的上下文状态是寄存器。有的MTmodel要求所有的寄存器都随时有效，而有的要求存储单元可以off core。 这些要求可以是一个MT的CPU的核心取舍。Architecture 寄存器的位置上最核心的成本性能取舍。    


**Chip multiprocessor**，又叫做multicore Processor， 是一种多线程的延续。 在Chip multi-processor中，核心资源，甚至L1都不共享。只有L2, L3, 互联网络，甚至是内存控制器是共享的。CMP 处理器的设计允许多个核心在同一个周期内同时执行不同线程的指令，因为每个核心都分配有自己的执行资源。  
chip multiprocessor没有能力去改变垂直浪费和水平浪费。但是这种浪费都会减少，因为发射贷款是平均静态分配的。因此每个核心的浪费对整体处理器的影响较小。   

比如，在一个4核的 CMP 中，如果每个核心是**2发射超标量** 架构，总的发射带宽是8。当一个线程被阻塞时，最多只有两个指令周期（来自一个核心）的发射带宽被浪费。  这种静态划分虽然限制了资源利用的灵活性，但带来了更好的隔离性和性能的可预测性，因为每个核心的资源是完全独立的。 

在 CMP 中，寄存器状态是分布在各个核心中的。因此，每个核心的寄存器文件的设计不比单核处理器的寄存器文件更复杂。    

**Conjoined Core Architectures**  
联合核心（Conjoined Cores） 是指多个核心**共享部分但不是全部执行资源的架构**。与传统的 CMP（芯片多处理器）不同，CMP 每个核心的资源是完全独立的，而在联合核心架构中，核心之间可以共享某些特定的资源，从而提高这些资源的利用率。  
这种架构设计的目标是模糊传统的核心边界，以便根据需求共享不常被单个核心充分使用的资源，从而最大化利用率和效率。  
可共享的资源包括L1/L2缓存， 浮点单元等等。 Conjoined 资源共享的具体方式上决定了其与 CMP 在应对水平浪费和垂直浪费上的相似性。如果浮点单元是共享的，而整数流水线不是共享的，那么浮点单元可以用来减少垂直浪费(为什么是垂直的？因为共享了资源，不用推迟CC？)，但整数单元则无法应对核心内的浪费。
例子：臭名昭著的AMD 推土机。





