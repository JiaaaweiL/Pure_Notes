# 线程
传统的操作系统中，每一个进程有一个地址空间和一个控制线程。不过，经常存在在同一个地址空间中准备并行运行多个控制线程的情形。这些线程就像分离的进程（共享地址空间）。人们需要多线程的主要原因是：在许多应用中同时发生着多种活动，其中某些活动随着时间的推移会被阻塞， 通过将这些应用分解成可以准并行运行的多个顺序线程，程序设计模型会变的简单。
	

### 拥有线程的原因：
- 1）有了多线程的概念之后，我们才加入了一种新的元素，并行的尸体拥有共享同一个地址空间和所有数据的能力。对于某些应用而言，这种能力是必须的，这是多进程模型无法表达的（多进程拥有不同的地址空间）
- 2）线程比进程更轻量级他们比进程更容易创建和撤销。在需要大量线程动态的和快速的修改时这一特性是有用的
- 3）如果多个线程都是CPU密集型，那么并不能获得性能上的增强。如果存在大量计算和大量I/O处理，拥有多个线程允许这些活动彼此重叠进行，从而会加快应用程序执行的速度。（说白了，系统级进步的方向在于藏延迟。乱序是藏RAW的延迟，cache是藏读写延迟，线程是藏IO延迟）

### 经典的线程模型：
线程模型基于两种独立的概念：资源分组处理与执行。理解线程的一个角度是：用某种方法把相关的资源集中在一起：打开的文件，子进程，即将发生的定时器，信号处理程序，账户信息。
另一个概念是：进程拥有一个执行的线程，拥有一个PC，寄存器和堆栈。

进程中的不同线程不像不同进程之间那样存在很大的独立性，所有线程都有完全一样的地址空间，这意味着他们也共享同样的全局变量。一个进程可以读写，清除另外一个线程的堆栈，他们之间是没有保护的。 
线程也可以处于若干态中的任何一个，运行，阻塞，就绪活终止。正在运行的线程拥有CPU并且是活跃的。被阻塞的线程正在等待某个释放它的时间。
每个线程拥有自己的堆栈。每个线程的堆栈有一帧，供哥哥被调用但是还没有从中返回的过程使用。栈帧中存放了相应的局部变量以及过程调用完之后的返回地址。
多线程的情况下，进程通常会从当前的单个线程开始，通过调用pthread_cread来创建新的线程，通过thread_exit退出， thead_yield让出线程。thead_yield十分重要，因为线程库无法利用时钟中断强制线程让出CPU，所有要让线程的运行“高尚”起来。

线程模型引入的问题：
- 如果父进程拥有多个线程，那么子进程也要拥有这些线程吗？ 是，如果不拥有，子进程可能不工作。
- 如果父进程在read系统调用（读键盘）上被阻塞了，会是什么情况？是两个线程被阻塞在键盘上吗？键盘输入之后，两个线程都会得到副本吗？
- 一个线程关闭了文件，一线程仍然在文件上读写，会有什么样的后果？
