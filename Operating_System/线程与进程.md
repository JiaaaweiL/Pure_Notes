# 进程
- 操作系统中最核心的概念是：进程， 进程是对正在运行程序的一个抽象。 即使可以使用的CPU只有一个，但他们也具有支持伪并发操作的能力，它们将一个单独的CPU变换成多个虚拟的CPU。
- 在任何的多道程序设计系统中，CPU由一个进程快速的切换至另一个进程，使每个进程各运行几十到几百毫秒。严格意义上，某一个瞬间，CPU只能运行一个进程，但在一秒钟内，他能运行多个进程，这样就产生了并行的错觉（伪并行）。以此来区分多处理器系统（能够实现真正的并行）。

###  进程模型：
假设一台多道程序计算机的内存中有4道程序， 四道程序被抽象为4个拥有自己控制流程的进程。这四道程序都有自己的PC（叫做逻辑PC），并且每个程序都独立地运行。切换到谁的时候，逻辑PC被装入真正的物理PC运行。给定的瞬间仅有一个进程正在运行。  
关键的思想是：一个进程是某种类型的一个活动，它有程序，输入，输出和状态，单个处理器可以被若干进程共享，它使用某种调度算法决定合适停止一个进程的工作，并转而为另一个进程提供服务。  

### 进程的创建：
操作系统需要一种方式来创建进程。通常有4中主要时间会导致进程的创建  
- 1） 系统初始化  
- 2） 正在运行的程序执行了创建进程的系统调用  
- 3） 用户请求创建一个新进程  
- 4） 一个批处理作业的初始化  

启动时，通常会创建若干进程，有前台进程和后台进程。  
- 前台进程同用户交互并且替他们完成工作。
- 后台进程通常与特定用户没有关系，但具备专门功能，例如一个后台进程来接收发来的电子邮件。

正在运行的进程经常启用系统调动，以创建一个或多个进程协助工作。
- 创建进程的逻辑是：所要从事的工作可以容易的划分成若干相关的但没有相互作用的进程时，创建新进程就特别有效果。

这是用户请求创建进程的例子： 通过键入一个命令/双击一个图标。

批处理的初始化的情景旨在大型机的批处理系统中应用。  

### 进程创建之后的空间问题
进程创建之后，父进程和子进程拥有**各自不同**的地址空间。如果其中的某个进程在其地址空间中修改了一个字，这个修改对其他的进程而言是不可见的。UNIX中，子进程的初始地址是父进程的一个副本，但是涉及两个不同的地址空间。不可写的内存区是**共享**的。可写的内存区域是**不可以共享**的（可以用写时复制），意味着，如果子/父进程二者之一想要修改内存，则这一块内存首先要被明确的复制，一确保修改发生在**私有内存区域**。 WINDOWS中，从一开始，子父进程的地址空间就是不同的

### 进程的终止：
进程终止可以由以下四个条件引起：
- 1） 正常退出（自愿的）
- 2） 出错退出（自愿的）
- 3） 严重错误（非自愿）
- 4） 被其他进程杀死（非自愿）

### 进程的层次结构： 
- UNIX中，进程和它的所有子进程以及后裔组成一个进程组。当用户从键盘发出一个信号时，该信号被送给当前与键盘相关的进程组中的所有成员。每个进程可以分别捕获信号，忽略信号，或采取默认动作。在整个系统中，所有的进程都属于以init为根的一棵树  
- WINDOWS中没有进程层次的概念，所有进程都是地位相同的。 创建进程的时候，父进程会得到一个特别的令牌（句柄） 该句柄可以用来控制子进程。但是它有权吧这个令牌传送给某个其他进程。  

### 进程的运行态
![image](https://github.com/user-attachments/assets/71d9f560-4644-4cc8-af2a-86e2a09c6e96)
进程的三态： 
- 运行态
- 就绪态
- 阻塞态。
  
有四种转换关系：
- 进程因为等待输入被阻塞（运行 -> 阻塞）  
- 调度程序选哪则另一个阻塞（运行 -> 就绪）  
- 调度程序选择这个进程 （就绪 -> 运行）  
- 出现有效输入 （阻塞 -> 就绪）  
	
操作系统发现进程不能继续运行下去时，选择转换1。转换2和3是由调度程序引起的。进程调度程序是操作系统的一部分，进程感觉不到调度程序存在。如果系统认为一个运行的进程占用CPU时间过长，或者公平问题，则会发生转换2和3. 当进程等待的一个外部事件发生时，则会发生转换4。如果这个时候没有其他进程运行，则发生转换3，否则该进程处于就绪态，等待CPU空闲并且轮到他运行。

使用进程模型使得我们易于想象系统内部的操作状况。一些进程正在运行执行用户键入命令锁对应的程序。另一些进程是系统的一部分，执行例如文件服务请求，管理磁盘等等。当发生一个磁盘中断时，系统会做出决定，停止当前进程，转而运行磁盘进程，磁盘进程在此前因为等待中断而处于阻塞态。用进程模型的一个好处是不用考虑处理中断，而是只考虑课启动的进程。  
在使用进程模型时，不必显式管理每个中断。操作系统通过以下方式简化了中断处理：  
- 进程阻塞和唤醒机制：当某个进程在等待某一事件（例如磁盘读取完成、用户输入等）时，它会进入阻塞状态，直到事件完成。在这个过程中，操作系统可以调度其他进程运行，而不必持续轮询或处理硬件中断。   
- 中断事件对应进程的唤醒：当硬件事件发生时，例如磁盘完成读取数据，系统的中断处理机制会自动将等待该事件的进程从阻塞状态唤醒，进程继续执行。这就避免了直接处理中断细节的问题。   

### 进程的实现： 
为了实现进程模型，操作系统维护着进程表。每个进程占一个entry。表格包含了进程状态的重要信息，包括PC， 堆栈指针，内存分配，所打开文件的状态，账户和调度等等信息，从而保证该进程随后能再次启动，就像从未被中断一样。



与每一IO类关联的是一个称作为中断向量的位置，它包含中断服务程序的入口地址。当一个磁盘中断发生时，用户进程3正在运行，则中断硬件将程序计数器，程序状态字，一个或多个寄存器压入堆栈，计算机随即跳转到中断向量所只是的地址。这些是HW完成的操作。然后软件，特别是中断服务例程就接管一切剩余工作。

所有中断都从保存寄存器开始，对于当前进程而言，通常是保存在进程表项中。随u后，会从堆栈中删除由中断硬件机制存入堆栈的那部分信息，并将堆栈指针指向一个由进程处理程序所使用的临时堆栈。一些诸如保存寄存器值和设置堆栈指针等操作可以由一个短小的汇编来完成。该例程可以供所有的中断使用。无论中断是怎样引起的，由管保存寄存器的工作是完全一样的。

当该例程结束后，他会调用一个C过程处理某个特定中断类型剩下的工作。完成有关工作的时候，接着调用调度程序，随后决定该运行那个进程。随后将控制转给一段汇编语言代码，为当前的进程装入寄存器值以及内存映射并启动该进程运行。
中断发生过后，操作系统最底层的工作步骤：
- 1）硬件压入堆栈程序计数器等
- 2）硬件从中断向量装入新的程序计数器
- 3）汇编语言过程保存寄存器值
- 4）汇编语言过程设置新的堆栈
- 5）C中断服务例程运行（读和缓冲输入）
- 6）调度程序决定下一个将运行的程序
- 7）C过程返回至汇编代码
- 8）汇编语言过程开始新的当前进程  

澄清：第三步为什么要汇编语言过程保存寄存器值/汇编语言设置新的堆栈是因为 中断只需要保存特定的，将要被使用的寄存器。因此那硬件指令（保存全部寄存器）浪费，且缺乏灵活性。设置新的堆栈需要依照中断种类设置。 -bygpt的合理答案  


